# AI Strength Coach Technical Specification

## 1. System Overview

*   **Core Purpose and Value Proposition:**
    AI Strength Coach is a lightweight, AI-driven strength training and hypertrophy workout application. It leverages a chat-based interface for users to generate personalized workout plans, log completed exercises, and visualize their progress over time. The primary value is providing an intelligent, frictionless way to plan and track strength training, focusing on data and progress rather than instructional content.

*   **Key Workflows:**
    1.  **Workout Generation:** User requests a workout plan via chat; AI generates and presents a structured plan.
    2.  **Workout Logging:** User describes completed exercises via chat; AI parses details (exercise, sets, reps, weight) and logs them.
    3.  **Progress Visualization:** User views a dashboard with charts (e.g., PR progression, training volume) derived from logged workouts.

*   **System Architecture:**
    *   **Framework:** Next.js 14 (App Router)
    *   **Language:** TypeScript
    *   **UI Components:** ShadCN UI
    *   **Styling:** Tailwind CSS
    *   **Charts:** Tremor
    *   **AI Integration:** Vercel AI SDK (using `useChat` hook and API routes) with an LLM (e.g., OpenAI GPT-3.5-turbo/GPT-4).
    *   **Database:** Vercel Postgres
    *   **ORM:** Prisma
    *   **Deployment:** Vercel
    *   **Font:** Geist Sans & Geist Mono

## 2. Project Structure

```
/ai-strength-coach
├── app/                            # Next.js App Router
│   ├── (app)/                    # Main application routes grouped
│   │   ├── page.tsx              # Main chat interface page (Route: /)
│   │   ├── dashboard/
│   │   │   └── page.tsx          # Progress dashboard page (Route: /dashboard)
│   │   └── layout.tsx            # Root layout for (app) group (contains shared UI like Nav)
│   ├── api/
│   │   └── chat/
│   │       └── route.ts          # API route for Vercel AI SDK chat interactions
│   ├── layout.tsx                # Root application layout (html, body, global providers)
│   └── global.css                # Global styles (Tailwind base, custom global styles)
├── components/
│   ├── ui/                       # ShadCN UI components (generated, e.g., button, input, card)
│   │   ├── button.tsx
│   │   ├── input.tsx
│   │   ├── card.tsx
│   │   ├── scroll-area.tsx
│   │   ├── tabs.tsx
│   │   └── ...                   # Other ShadCN components as needed
│   ├── chat/                     # Chat-specific composite components
│   │   ├── ChatInterface.tsx     # Main client component managing chat interactions via useChat
│   │   ├── ChatMessagesList.tsx  # Component to render the list of chat messages
│   │   ├── ChatMessageItem.tsx   # Component for an individual chat bubble (user/AI)
│   │   └── ChatInputArea.tsx     # Component for the text input and send button
│   ├── dashboard/                # Dashboard-specific components
│   │   ├── ExercisePRChart.tsx   # Tremor line chart for single exercise PR progression
│   │   ├── WeeklyVolumeChart.tsx # Tremor bar chart for weekly training volume
│   │   └── DashboardSection.tsx  # Wrapper component for a chart with title/description
│   └── shared/                   # Components shared across different views
│       ├── AppHeader.tsx         # Application header (e.g., with app title)
│       └── AppNavigation.tsx     # Navigation Tabs (Chat, Dashboard)
├── lib/
│   ├── ai/
│   │   ├── prompts.ts            # System prompts and specific instruction templates for LLM
│   │   └── parser.ts             # Functions to parse structured data from LLM responses
│   ├── db.ts                     # Prisma client instance initialization and export
│   ├── actions/                  # Server Actions
│   │   └── dashboard.actions.ts  # Server Actions for fetching dashboard data
│   ├── utils.ts                  # General utility functions (date formatting, string manipulation)
│   └── types.ts                  # Global TypeScript types and interfaces (e.g., WorkoutLog, ChartData)
├── prisma/
│   ├── schema.prisma             # Prisma schema definition
│   └── migrations/               # Database migration files generated by Prisma
├── public/                         # Static assets (favicon.ico, etc.)
├── styles/
│   └── fonts.ts                  # Geist font configuration using next/font
├── .env.example                  # Example environment variables
├── .env.local                    # Local environment variables (DATABASE_URL, OPENAI_API_KEY)
├── .eslintrc.json
├── .gitignore
├── next.config.mjs
├── package.json
├── postcss.config.js
├── tailwind.config.ts            # Tailwind CSS configuration including ShadCN preset and Geist font
└── tsconfig.json
```

## 3. Feature Specification

### 3.1 Chat Interface & AI Interaction

*   **User Story and Requirements:**
    *   As a user, I want to interact with an AI coach via a chat interface to get workout plans and log my workouts.
    *   The interface should display messages from me and the AI in a familiar chat bubble format.
    *   I should be able to type messages in an input field and send them by pressing "Enter" or clicking a send button.
    *   AI responses should stream in to feel conversational.
    *   The AI should understand requests to generate strength/hypertrophy workouts.
    *   The AI should understand natural language descriptions of completed exercises and extract relevant data (exercise, weight, sets, reps).
    *   The AI should provide contextual answers to simple training-related questions, within its defined scope.

*   **Detailed Implementation Steps:**
    1.  **Main Chat Page (`app/(app)/page.tsx`):**
        *   This page will primarily render the `ChatInterface` client component.
        *   It can be an RSC, simply embedding the client component.
    2.  **`ChatInterface.tsx` (Client Component):**
        *   Utilize Vercel AI SDK's `useChat` hook:
            *   `const { messages, input, handleInputChange, handleSubmit, isLoading, error } = useChat({ api: '/api/chat' });`
        *   State:
            *   `messages`: Array of message objects (from `useChat`).
            *   `input`: Current value of the input field (from `useChat`).
            *   `isLoading`: Boolean indicating if AI response is pending (from `useChat`).
        *   Render:
            *   `ChatMessagesList.tsx`: Pass `messages` array.
            *   `ChatInputArea.tsx`: Pass `input`, `handleInputChange`, `handleSubmit`, `isLoading`.
        *   Error handling: Display an error message if `error` from `useChat` is present.
    3.  **`ChatMessagesList.tsx` (Client Component):**
        *   Props: `messages: Message[]` (from `ai/react` package).
        *   Map through `messages` and render `ChatMessageItem.tsx` for each.
        *   Use `ScrollArea` (ShadCN) to make the list scrollable, automatically scrolling to the bottom on new messages.
    4.  **`ChatMessageItem.tsx` (Client Component):**
        *   Props: `message: Message`.
        *   Display message content (`message.content`).
        *   Style differently based on `message.role` (`user` or `assistant`). User messages on one side (e.g., right, primary color), AI messages on the other (e.g., left, secondary color).
        *   Optionally show a simple avatar/icon for user and AI.
    5.  **`ChatInputArea.tsx` (Client Component):**
        *   Props: `input`, `handleInputChange`, `handleSubmit`, `isLoading`.
        *   Render an `Input` (ShadCN) field bound to `input` and `handleInputChange`.
        *   Render a `Button` (ShadCN) to trigger `handleSubmit`. The button should be disabled if `isLoading` is true or `input` is empty.
        *   Allow submitting the form (and thus calling `handleSubmit`) by pressing "Enter" in the input field.
    6.  **API Route (`app/api/chat/route.ts`):**
        *   Use Vercel AI SDK helpers: `OpenAIStream` and `StreamingTextResponse`.
        *   Environment variables: `OPENAI_API_KEY`.
        *   Function `POST(req: Request)`:
            *   Extract `messages` from `await req.json()`.
            *   Get the latest user message: `const latestUserMessage = messages[messages.length - 1].content;`
            *   **Intent Detection (Simple Heuristic or LLM call):** Determine if the message is for:
                *   A. Workout Generation
                *   B. Workout Logging
                *   C. General Question
            *   **System Prompt Construction (in `lib/ai/prompts.ts`):**
                *   `getBaseSystemPrompt()`: Common instructions (act as AI Strength Coach, friendly, knowledgeable, focus on strength/hypertrophy, avoid medical advice).
                *   `getWorkoutGenerationPrompt(userRequest: string)`: Appends instructions for generating a structured plan. Specify desired output structure (e.g., "Exercises: [Exercise Name] - Sets: [Number] x Reps: [Number/Range] - Rest: [Time] optional_notes").
                *   `getWorkoutLoggingPrompt(userLog: string)`: Appends instructions for parsing user's log. Instruct to identify exercise name, weight, units (assume kg if not specified, or ask), sets, and reps per set. *Crucially, instruct the LLM to return a JSON object containing the parsed data within a specific marker (e.g., `<log_data>{...}</log_data>`) AND a conversational confirmation message.*
                *   `getGeneralQuestionPrompt()`: Basic prompt for Q&A.
            *   **LLM Interaction:**
                *   Construct the full prompt array for OpenAI: `[{ role: 'system', content: systemPromptContent }, ...messages]`
                *   `const response = await openai.chat.completions.create({ model: 'gpt-3.5-turbo', stream: true, messages: fullPromptArray });` (Model can be configurable)
            *   **Response Handling & Data Persistence (for logging):**
                *   If intent was "Workout Logging":
                    *   Collect the entire streamed response from the LLM first, *before* sending it to the client, if you need to parse data from it for the DB. Or, use `experimental_onCompletion` or `experimental_StreamData` if more advanced streaming and side-effects are needed.
                    *   A simpler approach for MVP: use the standard stream. When the stream completes on the server, capture the full AI text.
                    *   Then, after streaming, parse the collected AI response string (server-side) for the `<log_data>{...}</log_data>` JSON block using `lib/ai/parser.ts`.
                    *   If valid JSON is found:
                        *   Create/get `WorkoutSession` (e.g., for today's date, or create if not exists).
                        *   Create `ExerciseLog` entries using Prisma.
                        *   The streamed text to the user will be the AI's conversational part. The JSON parsing/DB save is an asynchronous side-effect.
            *   **Streaming Back:**
                *   `const stream = OpenAIStream(response, { onFinal: async (completion) => { /* Logging logic for NON-STREAMING parse after full response is received */ } });`
                *   Or better for simultaneous streaming and structured data: use Vercel AI SDK's `experimental_StreamData` to interleave structured data objects with the text stream. This is more advanced.
                *   For MVP: Stream text. Log after completion server-side if parsing the whole message. If AI is told to put JSON in the message, the message itself contains the data implicitly. The client won't act on it, the server will upon completion.
            *   Return `new StreamingTextResponse(stream)`.

*   **Error Handling and Edge Cases:**
    *   `ChatInterface.tsx`: Display `useChat` hook's `error` message if the API call fails.
    *   `/api/chat/route.ts`:
        *   Catch errors during OpenAI API calls and return an appropriate error response (e.g., `Response.json({ error: 'Failed to connect to AI service' }, { status: 500 })`).
        *   If workout logging data parsing fails:
            *   The AI's textual response should ideally indicate it couldn't understand or needs clarification (prompt engineering).
            *   Server logs an error, but does not break the chat.
        *   Handle empty user messages gracefully (frontend should prevent sending).
        *   Rate limiting (future consideration, not MVP): Implement if API costs become an issue.
        *   AI refusing to answer or giving off-topic replies: Refine system prompt.

### 3.2 Workout Logging & Tracking (Backend Focus)

*   **User Story and Requirements:**
    *   When I tell the AI what I did in my workout, it should understand and save this information to a database.
    *   Workout history should be stored by date and exercise.
    *   The system should be able to calculate my Personal Records (PRs) and training volume from this logged data.

*   **Detailed Implementation Steps (primarily within `/api/chat/route.ts` and Prisma schema):**
    1.  **Database Schema:** (Refer to Section 4) Define `WorkoutSession` and `ExerciseLog` tables.
    2.  **AI Prompt for Logging (`lib/ai/prompts.ts`):**
        *   `getWorkoutLoggingPrompt(userLog: string, currentDate: string)`:
            *   Include system prompt basics.
            *   "You are assisting a user in logging their workout. Parse the following user input: `{userLog}`."
            *   "Assume the workout happened on `{currentDate}` unless the user specifies another date."
            *   "Identify: exercise name, weight (assume kg if no unit, convert lbs to kg if specified), number of sets, and reps for each set."
            *   "Return your response as a conversational confirmation message. IMPORTANTLY, also embed a JSON object with the parsed data within `<log_data>` and `</log_data>` tags. The JSON should look like this: `{\"exerciseName\": \"string\", \"weightKg\": number, \"sets\": number, \"repsPerSet\": [number, number, ...], \"date\": \"YYYY-MM-DD\", \"notes\": \"string|null\"}`. If multiple exercises are logged in one message, return an array of these JSON objects."
            *   "If you are unsure or data is missing, ask for clarification in your conversational response and do NOT include the log_data tag."
    3.  **Parsing Logic (`lib/ai/parser.ts`):**
        *   `parseLogDataFromAIResponse(aiText: string): ParsedLogEntry[] | null`
            *   Uses regex or string manipulation to find and extract the JSON string between `<log_data>` and `</log_data>`.
            *   `JSON.parse()` the extracted string.
            *   Validate the parsed object structure against `ParsedLogEntry` type (defined in `lib/types.ts`).
            *   Return array of parsed entries or `null` if not found/invalid.
    4.  **Data Persistence Logic (in `/api/chat/route.ts` `onFinal` callback or after stream completion):**
        *   `prisma = new PrismaClient()` (or use shared instance from `lib/db.ts`).
        *   `async function logWorkoutData(parsedEntries: ParsedLogEntry[])`
            *   For each `entry` in `parsedEntries`:
                *   Find or create `WorkoutSession`:
                    *   `let session = await prisma.workoutSession.findFirst({ where: { date: new Date(entry.date), userId: /* 'guest_user_mvp' or null */ } });`
                    *   `if (!session) { session = await prisma.workoutSession.create({ data: { date: new Date(entry.date), userId: /* 'guest_user_mvp' */ } }); }`
                *   Create `ExerciseLog`:
                    *   `await prisma.exerciseLog.create({ data: { workoutSessionId: session.id, exerciseName: entry.exerciseName, // Basic normalization: entry.exerciseName.toLowerCase().trim() weightKg: entry.weightKg, sets: entry.sets, reps: entry.repsPerSet, // Prisma JSON field loggedAt: new Date(), notes: entry.notes } });`
    5.  **Triggering Logging:**
        *   In `/api/chat/route.ts`, after the OpenAI stream completes (e.g., in `onFinal` if supported, or after awaiting the full response for parsing if using simpler streaming):
            *   `const parsedData = parseLogDataFromAIResponse(aiFullTextResponse);`
            *   `if (parsedData) { await logWorkoutData(parsedData).catch(err => console.error("Failed to log workout data:", err)); }`
            *   This ensures logging happens asynchronously and doesn't block the chat response.

*   **Error Handling and Edge Cases:**
    *   **Normalization of `exerciseName`:** Basic: `toLowerCase().trim()`. Advanced (post-MVP): synonym mapping, Levenshtein distance for suggestions.
    *   **Units Conversion:** If AI is prompted to handle lbs, it should ideally convert to kg for consistent storage. Or store original unit and value. MVP: Assume kg unless AI is very good at unit conversion.
    *   **Ambiguous Logs:** AI should be prompted to ask for clarification. If it still tries to log, data validation on the server should be strict.
    *   **Database Errors:** Wrap Prisma calls in try/catch blocks. Log errors server-side. Chat should still function.
    *   **Concurrent Requests:** Prisma handles connection pooling. `WorkoutSession` findOrCreate needs to be robust if multiple logs for the same day arrive close together (DB constraints can help).

### 3.3 Data Visualization

*   **User Story and Requirements:**
    *   As a user, I want to see charts that show my training progress over time.
    *   I want to track trends for specific exercises (e.g., my Bench Press 1RM estimate).
    *   I want to see summaries of my training, like how much volume I did each week.

*   **Detailed Implementation Steps:**
    1.  **Dashboard Page (`app/(app)/dashboard/page.tsx`):**
        *   This page will be an RSC that fetches data using Server Actions and passes it to client components (the charts).
        *   `import { getExercisePRData, getWeeklyVolumeData } from '@/lib/actions/dashboard.actions';`
        *   `const exercisePRs = await getExercisePRData({ exerciseName: 'Bench Press' }); // Example`
        *   `const weeklyVolume = await getWeeklyVolumeData();`
        *   Render `ExercisePRChart` and `WeeklyVolumeChart` components, passing fetched data.
        *   May include a simple selector (client component) to choose the exercise for PR chart.
    2.  **Server Actions (`lib/actions/dashboard.actions.ts`):**
        *   `'use server';` directive.
        *   `import prisma from '@/lib/db';`
        *   `import { calculateEstimated1RM, aggregateVolumeByWeek } from '@/lib/utils'; // Placeholder for calc logic`
        *   `async function getExercisePRData(params: { exerciseName: string; userId?: string }): Promise<PRChartData[]>`
            *   Query `ExerciseLog` table:
                *   `const logs = await prisma.exerciseLog.findMany({ where: { exerciseName: { equals: params.exerciseName, mode: 'insensitive' }, /* userId: params.userId || 'guest_user_mvp' */ }, orderBy: { loggedAt: 'asc' } });`
            *   Process logs:
                *   For each log, calculate estimated 1RM (e.g., Epley formula: `weight * (1 + reps / 30)` if single high-rep set, or use highest weight for 1-5 reps directly as a PR point). For simplicity, MVP could plot max weight lifted for <= 5 reps.
                *   Return array like `[{ date: 'YYYY-MM-DD', e1RM: number }]`.
        *   `async function getWeeklyVolumeData(params: { userId?: string }): Promise<VolumeChartData[]>`
            *   Query `ExerciseLog`:
                *   `const logs = await prisma.exerciseLog.findMany({ where: { /* userId */ }, orderBy: { loggedAt: 'asc' } });`
            *   Process logs:
                *   Group logs by week.
                *   For each week, sum `(weightKg * repsInSet * numSets)`. `repsInSet` needs careful handling if `reps` is an array. `totalReps = repsPerSet.reduce((a, b) => a + b, 0)`. Volume = `weightKg * totalReps`.
                *   Return array like `[{ weekStartDate: 'YYYY-MM-DD', totalVolume: number }]`.
    3.  **Chart Components (Client Components in `components/dashboard/`):**
        *   `ExercisePRChart.tsx`:
            *   Props: `data: PRChartData[]`.
            *   Uses Tremor's `LineChart`.
            *   ` <LineChart data={data} index="date" categories={['e1RM']} yAxisWidth={60} /> `
        *   `WeeklyVolumeChart.tsx`:
            *   Props: `data: VolumeChartData[]`.
            *   Uses Tremor's `BarChart`.
            *   ` <BarChart data={data} index="weekStartDate" categories={['totalVolume']} yAxisWidth={60} /> `
        *   Use Tremor `Card`, `Title`, `Text` to wrap charts for better presentation.
    4.  **Navigation (`components/shared/AppNavigation.tsx`):**
        *   Use ShadCN `Tabs` component to switch between "Chat" (route `/`) and "Dashboard" (route `/dashboard`).
        *   Place this in `app/(app)/layout.tsx` so it's shared.

*   **Error Handling and Edge Cases:**
    *   No data available: Charts should display a "No data yet" message instead of breaking. Tremor charts handle empty `data` array gracefully.
    *   Data calculation errors in Server Actions: Log server-side. Return empty array or error object to page, display user-friendly message.
    *   Performance: For very large datasets, database queries might become slow. Ensure proper indexing. Paginate or summarize if needed (Post-MVP).

## 4. Database Schema

### 4.1 Tables

*   **`User`** (Primarily for future use, MVP uses a guest concept)
    *   `id`: String @id @default(cuid())
    *   `email`: String? @unique (Nullable for MVP, for future auth)
    *   `name`: String? (Nullable)
    *   `createdAt`: DateTime @default(now())
    *   `updatedAt`: DateTime @updatedAt
    *   `workoutSessions`: WorkoutSession[]
    *   `chatMessages`: ChatMessage[]

*   **`WorkoutSession`** (Represents a single workout instance)
    *   `id`: String @id @default(cuid())
    *   `date`: DateTime (Date of the workout)
    *   `name`: String? (Optional, e.g., "Push Day A", or AI generated title)
    *   `notes`: String? (Optional, user or AI notes about the session)
    *   `userId`: String? (Foreign Key to `User.id`, nullable for MVP single-user)
    *   `user`: User? @relation(fields: [userId], references: [id])
    *   `createdAt`: DateTime @default(now())
    *   `updatedAt`: DateTime @updatedAt
    *   `exerciseLogs`: ExerciseLog[]
    *   @@index([userId, date])

*   **`ExerciseLog`** (Represents a specific exercise performed during a session)
    *   `id`: String @id @default(cuid())
    *   `exerciseName`: String (e.g., "Bench Press". Needs normalization strategy.)
    *   `weightKg`: Float (Weight in kilograms)
    *   `sets`: Int (Number of sets performed)
    *   `repsPerSet`: Json (Array of reps for each set, e.g., `[10, 8, 8]`)
    *   `notes`: String? (Optional, e.g., "Felt strong", "RPE 8")
    *   `loggedAt`: DateTime @default(now()) (Timestamp when this specific log was entered)
    *   `workoutSessionId`: String (Foreign Key to `WorkoutSession.id`)
    *   `workoutSession`: WorkoutSession @relation(fields: [workoutSessionId], references: [id], onDelete: Cascade)
    *   `createdAt`: DateTime @default(now())
    *   `updatedAt`: DateTime @updatedAt
    *   @@index([workoutSessionId])
    *   @@index([exerciseName, loggedAt]) // For PR/trend tracking

*   **`ChatMessage`** (Stores the conversation history)
    *   `id`: String @id @default(cuid())
    *   `role`: String // "user", "assistant", "system" (Vercel AI SDK MessageRole)
    *   `content`: String @db.Text // Use Text for potentially long messages
    *   `userId`: String? (Foreign Key to User.id, nullable for MVP)
    *   `user`: User? @relation(fields: [userId], references: [id])
    *   `createdAt`: DateTime @default(now())
    *   @@index([userId, createdAt])

**Prisma Schema Snippet (`prisma/schema.prisma`):**
```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  // directUrl = env("DIRECT_URL") // For Vercel Postgres integration if needed
}

model User {
  id              String           @id @default(cuid())
  email           String?          @unique
  name            String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  workoutSessions WorkoutSession[]
  chatMessages    ChatMessage[]
}

model WorkoutSession {
  id            String        @id @default(cuid())
  date          DateTime
  name          String?
  notes         String?
  userId        String?
  user          User?         @relation(fields: [userId], references: [id])
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  exerciseLogs  ExerciseLog[]

  @@index([userId, date])
}

model ExerciseLog {
  id               String         @id @default(cuid())
  exerciseName     String
  weightKg         Float
  sets             Int
  repsPerSet       Json // e.g., [10, 8, 8]
  notes            String?
  loggedAt         DateTime       @default(now())
  workoutSessionId String
  workoutSession   WorkoutSession @relation(fields: [workoutSessionId], references: [id], onDelete: Cascade)
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  @@index([workoutSessionId])
  @@index([exerciseName, loggedAt])
}

model ChatMessage {
  id        String   @id @default(cuid())
  role      String // "user", "assistant", "system"
  content   String   @db.Text
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}
```
For MVP, `userId` can be consistently `null` or a fixed "guest" ID.

## 5. Server Actions

Server Actions will be used for data mutations and queries that don't fit the Vercel AI SDK's `useChat` flow, primarily for the dashboard.

### 5.1 Database Actions (via Server Actions in `lib/actions/`)

*   **`getExercisePRData`**
    *   **Description:** Fetches and processes `ExerciseLog` data to calculate Personal Record (PR) progression for a given exercise. For MVP, PR could be defined as the max weight lifted for a certain rep range (e.g., 1-5 reps) or an estimated 1RM.
    *   **Input Parameters:**
        *   `exerciseName`: `string` - The name of the exercise to track.
        *   `userId?`: `string` - (Optional for MVP, default to guest/null).
    *   **Return Value:** `Promise<Array<{ date: string; prValue: number }>>` - An array of objects, each representing a PR point with a date and value (e.g., estimated 1RM or max weight).
    *   **Prisma Operations:**
        ```typescript
        // In lib/actions/dashboard.actions.ts
        'use server';
        import prisma from '@/lib/db';
        import { calculateEstimated1RM } from '@/lib/utils'; // Implement this utility

        export async function getExercisePRData(
          params: { exerciseName: string; userId?: string }
        ): Promise<{ date: string; prValue: number }[]> {
          const logs = await prisma.exerciseLog.findMany({
            where: {
              exerciseName: { equals: params.exerciseName, mode: 'insensitive' },
              workoutSession: { userId: params.userId || null }, // Adjust if using a guest ID
            },
            orderBy: { loggedAt: 'asc' },
            select: { weightKg: true, repsPerSet: true, loggedAt: true }
          });

          // Example: Use max weight for 1-5 reps as PR indicator
          // A more robust e1RM would iterate through repsPerSet array for each log
          const prData = logs.map(log => {
            const repsArray = log.repsPerSet as number[];
            // Find max weight lifted for low reps (e.g. if any set has <= 5 reps, consider its weight for PR)
            // This logic is simplified; robust e1RM or PR definition is needed.
            let maxWeightLowRep = 0;
            // For simplicity, let's assume the first set's reps determines PR potential if reps <=5
            if (repsArray.length > 0 && repsArray[0] <= 5 && log.weightKg > 0) {
                 maxWeightLowRep = log.weightKg;
            }
            // Or use e1RM calculation
            const e1RM = calculateEstimated1RM(log.weightKg, repsArray[0] || 0); // Use first set for e1RM

            return {
              date: log.loggedAt.toISOString().split('T')[0], // Format as YYYY-MM-DD
              prValue: e1RM, // or maxWeightLowRep based on chosen PR definition
            };
          }).filter(p => p.prValue > 0); // Filter out non-PR entries

          // Further processing to ensure only actual new PRs are shown, or just plot all attempts.
          // For true PR progression, you'd only keep points where prValue is higher than previous.
          let currentMaxPr = 0;
          const actualPRs = prData.map(p => {
            if (p.prValue > currentMaxPr) {
                currentMaxPr = p.prValue;
                return { ...p, prValue: currentMaxPr };
            }
            return { ...p, prValue: currentMaxPr }; // Keep plotting the standing PR
          }).filter((value, index, self) => // Optional: Deduplicate if multiple logs on same day
            index === self.findIndex((t) => t.date === value.date && t.prValue === value.prValue)
          );
          return actualPRs;
        }
        ```

*   **`getWeeklyVolumeData`**
    *   **Description:** Fetches `ExerciseLog` data and aggregates total training volume (Weight * Sets * Reps) per week.
    *   **Input Parameters:** `userId?`: `string` (Optional for MVP).
    *   **Return Value:** `Promise<Array<{ weekStartDate: string; totalVolume: number }>>`
    *   **Prisma Operations:**
        ```typescript
        // In lib/actions/dashboard.actions.ts
        'use server';
        import prisma from '@/lib/db';
        import { getWeek } from 'date-fns'; // Using date-fns for week calculation

        export async function getWeeklyVolumeData(
          params: { userId?: string }
        ): Promise<{ weekStartDate: string; totalVolume: number }[]> {
          const logs = await prisma.exerciseLog.findMany({
            where: {
              workoutSession: { userId: params.userId || null }, // Adjust
            },
            orderBy: { loggedAt: 'asc' },
            select: { weightKg: true, sets: true, repsPerSet: true, loggedAt: true }
          });

          const weeklyVolumes: { [weekYear: string]: { totalVolume: number, date: Date } } = {};

          logs.forEach(log => {
            const repsArray = log.repsPerSet as number[];
            const totalRepsForExercise = repsArray.reduce((sum, r) => sum + r, 0);
            const volumeForExercise = log.weightKg * totalRepsForExercise; // Note: `sets` field in DB means sets recorded in this log. If repsPerSet covers all sets, use that.

            const year = log.loggedAt.getFullYear();
            const week = getWeek(log.loggedAt, { weekStartsOn: 1 }); // Monday as week start
            const weekYearKey = `${year}-W${String(week).padStart(2, '0')}`;
            
            // Get the actual start date of that week for charting
            // For simplicity in example, store first encountered date of that week. A more precise weekStartDate is better.
            const currentLogDate = new Date(log.loggedAt.getFullYear(), log.loggedAt.getMonth(), log.loggedAt.getDate());

            if (!weeklyVolumes[weekYearKey]) {
              weeklyVolumes[weekYearKey] = { totalVolume: 0, date: currentLogDate };
            }
            weeklyVolumes[weekYearKey].totalVolume += volumeForExercise;
            if(currentLogDate < weeklyVolumes[weekYearKey].date) { // Keep the earliest date as the representative date for the week start
                weeklyVolumes[weekYearKey].date = currentLogDate;
            }
          });
          
          return Object.entries(weeklyVolumes).map(([key, value]) => ({
            weekStartDate: value.date.toISOString().split('T')[0], // Use the representative date
            totalVolume: value.totalVolume,
          })).sort((a,b) => new Date(a.weekStartDate).getTime() - new Date(b.weekStartDate).getTime());
        }
        ```

*   **(Implicit) Data Logging actions are part of `/api/chat/route.ts`**
    *   **Description:** After AI parses workout log from chat, this logic persists it.
    *   **Input Parameters:** Parsed workout data (exercise name, weight, sets, reps, date).
    *   **Prisma Operations:** `prisma.workoutSession.findFirst/create`, `prisma.exerciseLog.create`. (Detailed in 3.2.4).

### 5.2 Other Actions (LLM Interaction is primary external "API")

*   **External API Integrations:**
    *   **OpenAI API:**
        *   **Endpoint:** `https://api.openai.com/v1/chat/completions`
        *   **Authentication:** Bearer token (`OPENAI_API_KEY` in environment variable).
        *   **Data Formats:** JSON request and streaming JSON response (handled by Vercel AI SDK).
        *   Managed via `/api/chat/route.ts`.
*   **File Handling Procedures:** None for MVP.
*   **Data Processing Algorithms:**
    *   **Estimated 1RM Calculation (`lib/utils.ts`):**
        *   `calculateEstimated1RM(weight: number, reps: number): number`
        *   Implements a common formula (e.g., Epley: `weight * (1 + reps / 30)`).
        *   Handle cases where reps are too high for reliable e1RM (e.g., reps > 12, return 0 or capped value).
    *   **Workout Log Parsing (`lib/ai/parser.ts`):** (Described in 3.2.3)
        *   Extracts structured JSON from LLM's text response.

## 6. Design System

### 6.1 Visual Style

*   **Theme:** Clean, minimal, mobile-first. Single light/neutral theme for MVP.
*   **Color Palette:**
    *   Backgrounds:
        *   `bg-background` (ShadCN): `hsl(0 0% 100%)` (Light) / `hsl(240 10% 3.9%)` (Dark - for reference if implemented)
        *   App Page BG: `slate-50` (`#F8FAFC`) or `gray-50` (`#F9FAFB`)
    *   Text/Foregrounds:
        *   `text-foreground` (ShadCN): `hsl(240 10% 3.9%)` (Light) / `hsl(0 0% 98%)` (Dark)
        *   `text-muted-foreground` (ShadCN): `hsl(240 3.8% 46.1%)` (Light) / `hsl(240 5% 64.9%)` (Dark)
    *   Primary/Accent (e.g., buttons, user chat bubble):
        *   `primary` (ShadCN): `hsl(240 5.9% 10%)` - This is default ShadCN. Can customize to a blue.
        *   Example Blue: `blue-600` (`#2563EB`), `text-primary-foreground` (ShadCN for text on primary): `hsl(0 0% 98%)`.
    *   Chat Bubbles:
        *   User: `bg-primary` (e.g., `blue-600`), `text-primary-foreground` (`white`).
        *   AI: `bg-muted` (ShadCN: `hsl(240 4.8% 95.9%)`), `text-muted-foreground`.
    *   Borders: `border` (ShadCN: `hsl(240 5.9% 90%)`).
    *   Charts (Tremor): Will inherit Tailwind/ShadCN theming as much as possible. Default Tremor colors are generally good.
*   **Typography:**
    *   **Font Families (`styles/fonts.ts` and `tailwind.config.ts`):**
        *   Primary UI & Text: `Geist Sans` (via `next/font/google` or local import if preferred)
            ```typescript
            // styles/fonts.ts
            import { GeistSans } from 'geist/font/sans';
            import { GeistMono } from 'geist/font/mono';

            export const geistSans = GeistSans;
            export const geistMono = GeistMono;
            ```
            ```typescript
            // tailwind.config.ts
            const { fontFamily } = require('tailwindcss/defaultTheme');
            module.exports = {
              // ...
              theme: {
                extend: {
                  fontFamily: {
                    sans: ['var(--font-geist-sans)', ...fontFamily.sans],
                    mono: ['var(--font-geist-mono)', ...fontFamily.mono],
                  },
                },
              },
            };
            ```
            ```typescript
            // app/layout.tsx
            import { geistSans, geistMono } from '@/styles/fonts';
            // ...
            <html lang="en" className={`${geistSans.variable} ${geistMono.variable}`}>...</html>
            ```
        *   Monospaced (if needed for data display): `Geist Mono`.
    *   **Sizes:** Utilize Tailwind's default type scale (`text-xs`, `sm`, `base`, `lg`, `xl`, etc.).
        *   Body text: `text-sm` or `text-base`.
        *   Headings: `text-lg`, `text-xl`, `text-2xl`.
    *   **Weights:** Normal (`font-normal`), Medium (`font-medium`), Semibold (`font-semibold`).
*   **Component Styling Patterns:** Rely on ShadCN UI component styles. Customizations via Tailwind utility classes applied directly or by overriding ShadCN component styles if necessary (though try to avoid this).
*   **Spacing and Layout Principles:** Use Tailwind's default spacing scale (multiples of 4px, e.g., `p-4`, `m-2`). Employ flexbox and grid for layout. Consistent padding within cards and sections.

### 6.2 Core Components

*   **Layout Structure (`app/(app)/layout.tsx`):**
    ```tsx
    import { AppHeader } from '@/components/shared/AppHeader';
    import { AppNavigation } from '@/components/shared/AppNavigation';

    export default function AppLayout({ children }: { children: React.ReactNode }) {
      return (
        <div className="flex flex-col min-h-screen bg-slate-50">
          <AppHeader />
          <main className="flex-grow container mx-auto px-4 py-8">
            <AppNavigation /> {/* Tabs for Chat/Dashboard */}
            <div className="mt-6">
              {children}
            </div>
          </main>
          {/* Optional Footer */}
        </div>
      );
    }
    ```
*   **Navigation Patterns (`components/shared/AppNavigation.tsx`):**
    *   Use ShadCN `Tabs`, `TabsList`, `TabsTrigger`, `TabsContent`.
    *   Triggers link to `/` (Chat) and `/dashboard` (Dashboard).
    *   The `TabsContent` will not be used directly; navigation handled by Next.js router. Active tab state managed by current path.
    ```tsx
    'use client'; // For using usePathname
    import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
    import Link from "next/link";
    import { usePathname } from "next/navigation";

    export function AppNavigation() {
      const pathname = usePathname();
      return (
        <Tabs defaultValue={pathname} className="w-full">
          <TabsList className="grid w-full grid-cols-2 md:w-[300px]">
            <TabsTrigger value="/" asChild>
              <Link href="/">Chat</Link>
            </TabsTrigger>
            <TabsTrigger value="/dashboard" asChild>
              <Link href="/dashboard">Dashboard</Link>
            </TabsTrigger>
          </TabsList>
        </Tabs>
      );
    }
    ```
*   **Shared Components (ShadCN UI predominantly):**
    *   `Button`: Props: `variant` (default, destructive, outline, secondary, ghost, link), `size` (default, sm, lg, icon).
        *   Usage: `<Button onClick={handler}>Send</Button>`
    *   `Input`: Standard input props (`type`, `placeholder`, `value`, `onChange`).
        *   Usage: `<Input placeholder="Type your message..." value={input} onChange={handleInputChange} />`
    *   `Card`, `CardHeader`, `CardTitle`, `CardDescription`, `CardContent`, `CardFooter`.
        *   Usage: Structuring dashboard elements.
    *   `ScrollArea`: For chat messages list.
    *   For chat specifics, see Section 3.1.
*   **Interactive States:**
    *   **Hover:** ShadCN components have built-in hover states. Use Tailwind `hover:` utilities for custom interactive elements.
    *   **Active/Focus:** ShadCN handles focus rings. Use Tailwind `focus:` utilities.
    *   **Disabled:** Use `disabled` prop on `Button`, `Input`. ShadCN styles disabled states.

## 7. Component Architecture

### 7.1 Server Components

*   **`app/(app)/page.tsx` (Chat Page):**
    *   RSC. Main role is to render the `<ChatInterface />` client component.
    *   No direct data fetching needed for this page itself beyond what `ChatInterface` orchestrates.
*   **`app/(app)/dashboard/page.tsx` (Dashboard Page):**
    *   RSC. Fetches initial data for charts using Server Actions.
    *   **Data Fetching:** `await getExercisePRData(...)`, `await getWeeklyVolumeData(...)`.
    *   **Suspense Boundaries:** Wrap chart components in `<Suspense fallback={<LoadingSpinner />}>` if data fetching is slow, or if multiple charts fetch independently.
        ```tsx
        // app/(app)/dashboard/page.tsx
        import { Suspense } from 'react';
        import { ExercisePRChart } from '@/components/dashboard/ExercisePRChart';
        import { WeeklyVolumeChart } from '@/components/dashboard/WeeklyVolumeChart';
        import { getExercisePRData, getWeeklyVolumeData } from '@/lib/actions/dashboard.actions';
        import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

        // Simple Loading component
        function ChartPlaceholder() { return <div className="h-64 bg-muted rounded-md flex items-center justify-center">Loading chart...</div> }

        export default async function DashboardPage() {
          // Example: Fetch for a common exercise by default, or allow selection via client component + re-fetch.
          // For simplicity, initial load shows one exercise. User interaction for other exercises is more complex.
          const benchPRs = await getExercisePRData({ exerciseName: 'Bench Press' });
          const weeklyVolume = await getWeeklyVolumeData();

          return (
            <div className="grid gap-6 md:grid-cols-2">
              <Card>
                <CardHeader><CardTitle>Bench Press PR Progression (e1RM)</CardTitle></CardHeader>
                <CardContent>
                  <Suspense fallback={<ChartPlaceholder />}>
                    <ExercisePRChart data={benchPRs} />
                  </Suspense>
                </CardContent>
              </Card>
              <Card>
                <CardHeader><CardTitle>Weekly Training Volume (kg)</CardTitle></CardHeader>
                <CardContent>
                  <Suspense fallback={<ChartPlaceholder />}>
                    <WeeklyVolumeChart data={weeklyVolume} />
                  </Suspense>
                </CardContent>
              </Card>
            </div>
          );
        }
        ```
    *   **Error Handling:** Server Actions should catch their own errors and return data that allows the component to render a fallback/error state. The page itself can use `error.tsx` for unhandled errors.
    *   **Props Interface:** Not directly applicable for page components in App Router, but data passed to child client components will have defined prop types.

### 7.2 Client Components

*   **`ChatInterface.tsx` (`components/chat/ChatInterface.tsx`):**
    *   `'use client';`
    *   **State Management:** Manages chat state via `useChat` hook from Vercel AI SDK.
    *   **Event Handlers:** `handleInputChange`, `handleSubmit` (from `useChat`).
    *   **UI Interactions:** Typing in input, clicking send, scrolling messages.
    *   **Props Interface:**
        ```typescript
        // No explicit props needed if it's self-contained for the main page
        // interface ChatInterfaceProps {}
        ```
*   **`ChatMessageList.tsx`, `ChatMessageItem.tsx`, `ChatInputArea.tsx`:** (as described in 3.1)
    *   Props are mainly message data and handlers passed down from `ChatInterface`.
*   **Chart Components (e.g., `components/dashboard/ExercisePRChart.tsx`):**
    *   `'use client';`
    *   **State Management:** May have internal state for chart options if complex, but primarily display components.
    *   **Event Handlers:** Tremor charts have built-in hover/tooltip handlers.
    *   **UI Interactions:** Viewing tooltips.
    *   **Props Interface:**
        ```typescript
        // components/dashboard/ExercisePRChart.tsx
        import { LineChart } from '@tremor/react';
        // Type defined in lib/types.ts
        // export type PRChartData = { date: string; prValue: number; };

        interface ExercisePRChartProps {
          data: PRChartData[]; // This would be imported from lib/types.ts
        }

        export function ExercisePRChart({ data }: ExercisePRChartProps) {
          if (!data || data.length === 0) {
            return <p className="text-muted-foreground">No data available for this exercise.</p>;
          }
          return (
            <LineChart
              className="h-72"
              data={data}
              index="date"
              categories={['prValue']}
              colors={['blue']} // Customize Tremor colors
              yAxisWidth={60}
              valueFormatter={(value) => `${value.toFixed(1)} kg`}
            />
          );
        }
        ```

## 8. Authentication & Authorization

*   **MVP: No User Authentication.**
    *   All data is treated as if belonging to a single "guest" user.
    *   Database schema includes `userId` fields, which will be `NULL` or a fixed guest ID for the MVP.
    *   No protected routes specific to users.
*   **Future Implementation:** Consider Vercel Authentication, NextAuth.js, or Clerk.
    *   When implemented, API routes and Server Actions will need to verify user sessions and use the authenticated `userId` for database queries and mutations.
    *   Protected routes will be configured using Next.js Middleware or by checking session status in page/layout components.
    *   Session management will be handled by the chosen auth provider.

## 9. Data Flow

*   **Chat Input -> AI -> Database:**
    1.  User types in `ChatInputArea.tsx` (Client Component).
    2.  State (`input`) updated via `handleInputChange` (`useChat`).
    3.  User submits (Enter/Click) -> `handleSubmit` (`useChat`) called.
    4.  `useChat` appends user message to `messages` state (optimistic update) and sends array of `messages` to `/api/chat` (Server).
    5.  `/api/chat` (Server API Route):
        *   Receives messages.
        *   Constructs prompt for LLM (OpenAI).
        *   Sends prompt to LLM.
        *   Receives streaming response from LLM.
        *   Simultaneously streams this text response back to `useChat`.
        *   (Asynchronously, on completion or via specialized streaming) If AI response indicates a workout log:
            *   Parses structured log data from AI response (`lib/ai/parser.ts`).
            *   Saves parsed data to Vercel Postgres via Prisma (`WorkoutSession`, `ExerciseLog`).
    6.  `useChat` (Client) receives streamed AI response, updates `messages` state.
    7.  `ChatMessagesList.tsx` re-renders with new AI message.
*   **Dashboard Data Fetching -> Display:**
    1.  User navigates to `/dashboard`.
    2.  `app/(app)/dashboard/page.tsx` (RSC) executes.
    3.  Server Actions (`getExercisePRData`, `getWeeklyVolumeData`) are called (`await`).
    4.  Server Actions query Vercel Postgres via Prisma.
    5.  Data is aggregated/processed.
    6.  Processed data is returned from Server Actions.
    7.  `DashboardPage` RSC passes data as props to Client Components (`ExercisePRChart.tsx`, `WeeklyVolumeChart.tsx`).
    8.  Client chart components render using Tremor.

## 10. Stripe Integration

*   **Not applicable for MVP.**

## 11. PostHog Analytics

*   **Not applicable for MVP.**

## 12. Testing

*   **Unit Tests (Jest/Vitest with React Testing Library):**
    *   **`lib/utils.ts`:**
        *   `calculateEstimated1RM(100, 5)` should return `116.6...`.
        *   `calculateEstimated1RM(50, 15)` should handle high reps (return 0 or capped).
    *   **`lib/ai/parser.ts`:**
        *   `parseLogDataFromAIResponse("<log_data>{\"exerciseName\": \"Bench Press\", ...}</log_data>")` should correctly parse JSON.
        *   Test with malformed JSON, missing tags, multiple entries.
    *   **`lib/ai/prompts.ts`:**
        *   Test prompt generation functions to ensure correct inclusion of user input and instructions.
    *   **Client Components (`components/chat/ChatMessageItem.tsx`):**
        *   Render user message correctly.
        *   Render AI message correctly.
    *   **Server Actions (`lib/actions/dashboard.actions.ts`):**
        *   Mock Prisma client (`vitest-mock-extended` or Jest manual mocks).
        *   Test `getExercisePRData` with mock DB data, ensure correct aggregation and e1RM calculation.
        *   Test `getWeeklyVolumeData` for correct weekly grouping and volume sum.
*   **End-to-End Tests (Playwright):**
    *   **Key User Flows:**
        1.  **Generate Workout Plan:**
            *   Navigate to chat page.
            *   Type "create a 3 day ppl program" and send.
            *   Verify AI response appears in the chat list and contains expected keywords (e.g., "Push Day", "Squat").
        2.  **Log Workout:**
            *   Type "logged bench press 100kg 3 sets of 5 reps" and send.
            *   Verify AI confirmation message ("Logged bench press...") appears.
            *   (Harder to test directly) Indirectly verify by navigating to dashboard and seeing if new data affects charts (requires DB seeding or ability to inspect DB state).
        3.  **View Progress Dashboard:**
            *   Navigate to dashboard page.
            *   Verify "Bench Press PR Progression" chart is visible.
            *   Verify "Weekly Training Volume" chart is visible.
            *   (With seeded data) Verify charts display some data points.
    *   **Playwright Test Example (Conceptual):**
        ```typescript
        // tests/e2e/chat.spec.ts
        import { test, expect } from '@playwright/test';

        test.beforeEach(async ({ page }) => {
          await page.goto('/');
        });

        test('should allow user to send a message and receive an AI response', async ({ page }) => {
          await page.fill('input[placeholder="Send a message..."]', 'Hello AI');
          await page.click('button:has-text("Send")'); // Or simulate Enter press

          // Wait for AI response to appear (use a specific selector for AI messages)
          const aiMessage = page.locator('.ai-message-class').last(); // Fictitious class
          await expect(aiMessage).toBeVisible({ timeout: 20000 }); // Increased timeout for AI response
          await expect(aiMessage).not.toBeEmpty();
        });

        test('should log a workout and confirm', async ({ page }) => {
            await page.fill('input[placeholder="Send a message..."]', 'Log Squats 120kg 3x5');
            await page.getByRole('button', { name: /send/i }).click(); // Adjust selector
      
            const aiMessage = page.locator('.ai-message-class').last();
            await expect(aiMessage).toContainText(/logged squats 120kg/i, { timeout: 20000 });
        });
        ```

This technical specification provides a comprehensive plan for developing the AI Strength Coach MVP. Adaptations and clarifications may be needed during implementation based on challenges encountered or new insights.